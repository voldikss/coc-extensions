{
  "BasedOnStyle": {
    "type": "string",
    "description": "  The style used for all options not specifically set in the configuration.\n\n  This option is supported only in the :program:`clang-format` configuration\n  (both within ``-style='{...}'`` and the ``.clang-format`` file).\n\n    Possible values:\n\n",
    "enum": {
      "LLVM": "    A style complying with the `LLVM coding standards\n    <https://llvm.org/docs/CodingStandards.html>`_\n",
      "Google": "    A style complying with `Google's C++ style guide\n    <https://google.github.io/styleguide/cppguide.html>`_\n",
      "Chromium": "    A style complying with `Chromium's style guide\n    <https://chromium.googlesource.com/chromium/src/+/master/styleguide/styleguide.md>`_\n",
      "Mozilla": "    A style complying with `Mozilla's style guide\n    <https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style>`_\n",
      "WebKit": "    A style complying with `WebKit's style guide\n    <https://www.webkit.org/coding/coding-style.html>`_\n",
      "Microsoft": "    A style complying with `Microsoft's style guide\n    <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017>`_\n",
      "GNU": "    A style complying with the `GNU coding standards\n    <https://www.gnu.org/prep/standards/standards.html>`_\n",
      "InheritParentConfig": "    Not a real style, but allows to use the ``.clang-format`` file from the\n    parent directory (or its parent if there is none). If there is no parent\n    file found it falls back to the ``fallback`` style, and applies the changes\n    to that.\n\n    With this option you can overwrite some parts of your main style for your\n    subdirectories. This is also possible through the command line, e.g.:\n    ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``\n\n.. START_FORMAT_STYLE_OPTIONS\n\n"
    }
  },
  "AccessModifierOffset": {
    "type": "int",
    "description": "  The extra indent or outdent of access modifiers, e.g. ``public:``.\n\n"
  },
  "AlignAfterOpenBracket": {
    "type": "BracketAlignmentStyle",
    "description": "  If ``true``, horizontally aligns arguments after an open bracket.\n\n  This applies to round brackets (parentheses), angle brackets and square\n  brackets.\n\n    Possible values:\n\n",
    "enum": {
      "BAS_Align": "    Align parameters on the open bracket, e.g.:\n\n```cpp\n\n      someLongFunction(argument1,\n                       argument2);\n\n```\n\n",
      "BAS_DontAlign": "    Don't align, instead use ``ContinuationIndentWidth``, e.g.:\n\n```cpp\n\n      someLongFunction(argument1,\n          argument2);\n\n```\n\n",
      "BAS_AlwaysBreak": "    Always break after an open bracket, if the parameters don't fit\n    on a single line, e.g.:\n\n```cpp\n\n      someLongFunction(\n          argument1, argument2);\n\n\n\n```\n\n"
    }
  },
  "AlignConsecutiveAssignments": {
    "type": "AlignConsecutiveStyle",
    "description": "  Style of aligning consecutive assignments.\n\n  ``Consecutive`` will result in formattings like:\n\n```cpp\n\n    int a            = 1;\n    int somelongname = 2;\n    double c         = 3;\n\n    Possible values:\n\n```",
    "enum": {
      "ACS_None": "     Do not align assignments on consecutive lines.\n\n",
      "ACS_Consecutive": "     Align assignments on consecutive lines. This will result in\n     formattings like:\n\n```cpp\n\n       int a            = 1;\n       int somelongname = 2;\n       double c         = 3;\n\n       int d = 3;\n       /* A comment. */\n       double e = 4;\n\n```\n\n",
      "ACS_AcrossEmptyLines": "     Same as ACS_Consecutive, but also spans over empty lines, e.g.\n\n```cpp\n\n       int a            = 1;\n       int somelongname = 2;\n       double c         = 3;\n\n       int d            = 3;\n       /* A comment. */\n       double e = 4;\n\n```\n\n",
      "ACS_AcrossComments": "     Same as ACS_Consecutive, but also spans over lines only containing\n     comments, e.g.\n\n```cpp\n\n       int a            = 1;\n       int somelongname = 2;\n       double c         = 3;\n\n       int d    = 3;\n       /* A comment. */\n       double e = 4;\n\n```\n\n",
      "ACS_AcrossEmptyLinesAndComments": "    (in configuration: ``AcrossEmptyLinesAndComments``)\n\n     Same as ACS_Consecutive, but also spans over lines only containing\n     comments and empty lines, e.g.\n\n```cpp\n\n       int a            = 1;\n       int somelongname = 2;\n       double c         = 3;\n\n       int d            = 3;\n       /* A comment. */\n       double e         = 4;\n\n```\n\n"
    }
  },
  "AlignConsecutiveBitFields": {
    "type": "AlignConsecutiveStyle",
    "description": "  Style of aligning consecutive bit field.\n\n  ``Consecutive`` will align the bitfield separators of consecutive lines.\n  This will result in formattings like:\n\n```cpp\n\n    int aaaa : 1;\n    int b    : 12;\n    int ccc  : 8;\n\n    Possible values:\n\n```",
    "enum": {
      "ACS_None": "     Do not align bit fields on consecutive lines.\n\n",
      "ACS_Consecutive": "     Align bit fields on consecutive lines. This will result in\n     formattings like:\n\n```cpp\n\n       int aaaa : 1;\n       int b    : 12;\n       int ccc  : 8;\n\n       int d : 2;\n       /* A comment. */\n       int ee : 3;\n\n```\n\n",
      "ACS_AcrossEmptyLines": "     Same as ACS_Consecutive, but also spans over empty lines, e.g.\n\n```cpp\n\n       int aaaa : 1;\n       int b    : 12;\n       int ccc  : 8;\n\n       int d    : 2;\n       /* A comment. */\n       int ee : 3;\n\n```\n\n",
      "ACS_AcrossComments": "     Same as ACS_Consecutive, but also spans over lines only containing\n     comments, e.g.\n\n```cpp\n\n       int aaaa : 1;\n       int b    : 12;\n       int ccc  : 8;\n\n       int d  : 2;\n       /* A comment. */\n       int ee : 3;\n\n```\n\n",
      "ACS_AcrossEmptyLinesAndComments": "    (in configuration: ``AcrossEmptyLinesAndComments``)\n\n     Same as ACS_Consecutive, but also spans over lines only containing\n     comments and empty lines, e.g.\n\n```cpp\n\n       int aaaa : 1;\n       int b    : 12;\n       int ccc  : 8;\n\n       int d    : 2;\n       /* A comment. */\n       int ee   : 3;\n\n```\n\n"
    }
  },
  "AlignConsecutiveDeclarations": {
    "type": "AlignConsecutiveStyle",
    "description": "  Style of aligning consecutive declarations.\n\n  ``Consecutive`` will align the declaration names of consecutive lines.\n  This will result in formattings like:\n\n```cpp\n\n    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc;\n\n    Possible values:\n\n```",
    "enum": {
      "ACS_None": "     Do not align bit declarations on consecutive lines.\n\n",
      "ACS_Consecutive": "     Align declarations on consecutive lines. This will result in\n     formattings like:\n\n```cpp\n\n       int         aaaa = 12;\n       float       b = 23;\n       std::string ccc;\n\n       int a = 42;\n       /* A comment. */\n       bool c = false;\n\n```\n\n",
      "ACS_AcrossEmptyLines": "     Same as ACS_Consecutive, but also spans over empty lines, e.g.\n\n```cpp\n\n       int         aaaa = 12;\n       float       b = 23;\n       std::string ccc;\n\n       int         a = 42;\n       /* A comment. */\n       bool c = false;\n\n```\n\n",
      "ACS_AcrossComments": "     Same as ACS_Consecutive, but also spans over lines only containing\n     comments, e.g.\n\n```cpp\n\n       int         aaaa = 12;\n       float       b = 23;\n       std::string ccc;\n\n       int  a = 42;\n       /* A comment. */\n       bool c = false;\n\n```\n\n",
      "ACS_AcrossEmptyLinesAndComments": "    (in configuration: ``AcrossEmptyLinesAndComments``)\n\n     Same as ACS_Consecutive, but also spans over lines only containing\n     comments and empty lines, e.g.\n\n```cpp\n\n       int         aaaa = 12;\n       float       b = 23;\n       std::string ccc;\n\n       int         a = 42;\n       /* A comment. */\n       bool        c = false;\n\n```\n\n"
    }
  },
  "AlignConsecutiveMacros": {
    "type": "AlignConsecutiveStyle",
    "description": "  Style of aligning consecutive macro definitions.\n\n  ``Consecutive`` will result in formattings like:\n\n```cpp\n\n    #define SHORT_NAME       42\n    #define LONGER_NAME      0x007f\n    #define EVEN_LONGER_NAME (2)\n    #define foo(x)           (x * x)\n    #define bar(y, z)        (y + z)\n\n    Possible values:\n\n```",
    "enum": {
      "ACS_None": "     Do not align macro definitions on consecutive lines.\n\n",
      "ACS_Consecutive": "     Align macro definitions on consecutive lines. This will result in\n     formattings like:\n\n```cpp\n\n       #define SHORT_NAME       42\n       #define LONGER_NAME      0x007f\n       #define EVEN_LONGER_NAME (2)\n\n       #define foo(x) (x * x)\n       /* some comment */\n       #define bar(y, z) (y + z)\n\n```\n\n",
      "ACS_AcrossEmptyLines": "     Same as ACS_Consecutive, but also spans over empty lines, e.g.\n\n```cpp\n\n       #define SHORT_NAME       42\n       #define LONGER_NAME      0x007f\n       #define EVEN_LONGER_NAME (2)\n\n       #define foo(x)           (x * x)\n       /* some comment */\n       #define bar(y, z) (y + z)\n\n```\n\n",
      "ACS_AcrossComments": "     Same as ACS_Consecutive, but also spans over lines only containing\n     comments, e.g.\n\n```cpp\n\n       #define SHORT_NAME       42\n       #define LONGER_NAME      0x007f\n       #define EVEN_LONGER_NAME (2)\n\n       #define foo(x)    (x * x)\n       /* some comment */\n       #define bar(y, z) (y + z)\n\n```\n\n",
      "ACS_AcrossEmptyLinesAndComments": "    (in configuration: ``AcrossEmptyLinesAndComments``)\n\n     Same as ACS_Consecutive, but also spans over lines only containing\n     comments and empty lines, e.g.\n\n```cpp\n\n       #define SHORT_NAME       42\n       #define LONGER_NAME      0x007f\n       #define EVEN_LONGER_NAME (2)\n\n       #define foo(x)           (x * x)\n       /* some comment */\n       #define bar(y, z)        (y + z)\n\n```\n\n"
    }
  },
  "AlignEscapedNewlines": {
    "type": "EscapedNewlineAlignmentStyle",
    "description": "  Options for aligning backslashes in escaped newlines.\n\n    Possible values:\n\n",
    "enum": {
      "ENAS_DontAlign": "    Don't align escaped newlines.\n\n```cpp\n\n      #define A \\\n        int aaaa; \\\n        int b; \\\n        int dddddddddd;\n\n```\n\n",
      "ENAS_Left": "    Align escaped newlines as far left as possible.\n\n```cpp\n\n      true:\n      #define A   \\\n        int aaaa; \\\n        int b;    \\\n        int dddddddddd;\n\n      false:\n\n```\n\n",
      "ENAS_Right": "    Align escaped newlines in the right-most column.\n\n```cpp\n\n      #define A                                                                      \\\n        int aaaa;                                                                    \\\n        int b;                                                                       \\\n        int dddddddddd;\n\n\n\n```\n\n"
    }
  },
  "AlignOperands": {
    "type": "OperandAlignmentStyle",
    "description": "  If ``true``, horizontally align operands of binary and ternary\n  expressions.\n\n    Possible values:\n\n",
    "enum": {
      "OAS_DontAlign": "    Do not align operands of binary and ternary expressions.\n    The wrapped lines are indented ``ContinuationIndentWidth`` spaces from\n    the start of the line.\n\n",
      "OAS_Align": "    Horizontally align operands of binary and ternary expressions.\n\n    Specifically, this aligns operands of a single expression that needs\n    to be split over multiple lines, e.g.:\n\n```cpp\n\n      int aaa = bbbbbbbbbbbbbbb +\n                ccccccccccccccc;\n\n    When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is\n    aligned with the operand on the first line.\n\n```cpp\n\n      int aaa = bbbbbbbbbbbbbbb\n                + ccccccccccccccc;\n\n```\n\n",
      "OAS_AlignAfterOperator": "    Horizontally align operands of binary and ternary expressions.\n\n    This is similar to ``AO_Align``, except when\n    ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so\n    that the wrapped operand is aligned with the operand on the first line.\n\n```cpp\n\n      int aaa = bbbbbbbbbbbbbbb\n              + ccccccccccccccc;\n\n\n\n```\n\n"
    }
  },
  "AlignTrailingComments": {
    "type": "bool",
    "description": "  If ``true``, aligns trailing comments.\n\n```cpp\n\n    true:                                   false:\n    int a;     // My comment a      vs.     int a; // My comment a\n    int b = 2; // comment  b                int b = 2; // comment about b\n\n```"
  },
  "AllowAllArgumentsOnNextLine": {
    "type": "bool",
    "description": "  If a function call or braced initializer list doesn't fit on a\n  line, allow putting all arguments onto the next line, even if\n  ``BinPackArguments`` is ``false``.\n\n```cpp\n\n    true:\n    callFunction(\n        a, b, c, d);\n\n    false:\n    callFunction(a,\n                 b,\n                 c,\n                 d);\n\n```"
  },
  "AllowAllConstructorInitializersOnNextLine": {
    "type": "bool",
    "description": "  If a constructor definition with a member initializer list doesn't\n  fit on a single line, allow putting all member initializers onto the next\n  line, if ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is true.\n  Note that this parameter has no effect if\n  ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is false.\n\n```cpp\n\n    true:\n    MyClass::MyClass() :\n        member0(0), member1(2) {}\n\n    false:\n    MyClass::MyClass() :\n        member0(0),\n        member1(2) {}\n\n```"
  },
  "AllowAllParametersOfDeclarationOnNextLine": {
    "type": "bool",
    "description": "  If the function declaration doesn't fit on a line,\n  allow putting all parameters of a function declaration onto\n  the next line even if ``BinPackParameters`` is ``false``.\n\n```cpp\n\n    true:\n    void myFunction(\n        int a, int b, int c, int d, int e);\n\n    false:\n    void myFunction(int a,\n                    int b,\n                    int c,\n                    int d,\n                    int e);\n\n```"
  },
  "AllowShortBlocksOnASingleLine": {
    "type": "ShortBlockStyle",
    "description": "  Dependent on the value, ``while (true) { continue; }`` can be put on a\n  single line.\n\n    Possible values:\n\n",
    "enum": {
      "SBS_Never": "    Never merge blocks into a single line.\n\n```cpp\n\n      while (true) {\n      }\n      while (true) {\n        continue;\n      }\n\n```\n\n",
      "SBS_Empty": "    Only merge empty blocks.\n\n```cpp\n\n      while (true) {}\n      while (true) {\n        continue;\n      }\n\n```\n\n",
      "SBS_Always": "    Always merge short blocks into a single line.\n\n```cpp\n\n      while (true) {}\n      while (true) { continue; }\n\n\n\n```\n\n"
    }
  },
  "AllowShortCaseLabelsOnASingleLine": {
    "type": "bool",
    "description": "  If ``true``, short case labels will be contracted to a single line.\n\n```cpp\n\n    true:                                   false:\n    switch (a) {                    vs.     switch (a) {\n    case 1: x = 1; break;                   case 1:\n    case 2: return;                           x = 1;\n    }                                         break;\n                                            case 2:\n                                              return;\n                                            }\n\n```"
  },
  "AllowShortEnumsOnASingleLine": {
    "type": "bool",
    "description": "  Allow short enums on a single line.\n\n```cpp\n\n    true:\n    enum { A, B } myEnum;\n\n    false:\n    enum\n    {\n      A,\n      B\n    } myEnum;\n\n```"
  },
  "AllowShortFunctionsOnASingleLine": {
    "type": "ShortFunctionStyle",
    "description": "  Dependent on the value, ``int f() { return 0; }`` can be put on a\n  single line.\n\n    Possible values:\n\n",
    "enum": {
      "SFS_None": "    Never merge functions into a single line.\n\n",
      "SFS_InlineOnly": "    Only merge functions defined inside a class. Same as \"inline\",\n    except it does not implies \"empty\": i.e. top level empty functions\n    are not merged either.\n\n```cpp\n\n      class Foo {\n        void f() { foo(); }\n      };\n      void f() {\n        foo();\n      }\n      void f() {\n      }\n\n```\n\n",
      "SFS_Empty": "    Only merge empty functions.\n\n```cpp\n\n      void f() {}\n      void f2() {\n        bar2();\n      }\n\n```\n\n",
      "SFS_Inline": "    Only merge functions defined inside a class. Implies \"empty\".\n\n```cpp\n\n      class Foo {\n        void f() { foo(); }\n      };\n      void f() {\n        foo();\n      }\n      void f() {}\n\n```\n\n",
      "SFS_All": "    Merge all functions fitting on a single line.\n\n```cpp\n\n      class Foo {\n        void f() { foo(); }\n      };\n      void f() { bar(); }\n\n\n\n```\n\n"
    }
  },
  "AllowShortIfStatementsOnASingleLine": {
    "type": "ShortIfStyle",
    "description": "  If ``true``, ``if (a) return;`` can be put on a single line.\n\n    Possible values:\n\n",
    "enum": {
      "SIS_Never": "    Never put short ifs on the same line.\n\n```cpp\n\n      if (a)\n        return ;\n      else {\n        return;\n      }\n\n```\n\n",
      "SIS_WithoutElse": "    Without else put short ifs on the same line only if\n    the else is not a compound statement.\n\n```cpp\n\n      if (a) return;\n      else\n        return;\n\n```\n\n",
      "SIS_Always": "    Always put short ifs on the same line if\n    the else is not a compound statement or not.\n\n```cpp\n\n      if (a) return;\n      else {\n        return;\n      }\n\n\n\n```\n\n"
    }
  },
  "AllowShortLambdasOnASingleLine": {
    "type": "ShortLambdaStyle",
    "description": "  Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a\n  single line.\n\n    Possible values:\n\n",
    "enum": {
      "SLS_None": "    Never merge lambdas into a single line.\n\n",
      "SLS_Empty": "    Only merge empty lambdas.\n\n```cpp\n\n      auto lambda = [](int a) {}\n      auto lambda2 = [](int a) {\n          return a;\n      };\n\n```\n\n",
      "SLS_Inline": "    Merge lambda into a single line if argument of a function.\n\n```cpp\n\n      auto lambda = [](int a) {\n          return a;\n      };\n      sort(a.begin(), a.end(), ()[] { return x < y; })\n\n```\n\n",
      "SLS_All": "    Merge all lambdas fitting on a single line.\n\n```cpp\n\n      auto lambda = [](int a) {}\n      auto lambda2 = [](int a) { return a; };\n\n\n\n```\n\n"
    }
  },
  "AllowShortLoopsOnASingleLine": {
    "type": "bool",
    "description": "  If ``true``, ``while (true) continue;`` can be put on a single\n  line.\n\n"
  },
  "AlwaysBreakAfterDefinitionReturnType": {
    "type": "DefinitionReturnTypeBreakingStyle",
    "description": "  The function definition return type breaking style to use.  This\n  option is **deprecated** and is retained for backwards compatibility.\n\n    Possible values:\n\n",
    "enum": {
      "DRTBS_None": "    Break after return type automatically.\n    ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n\n",
      "DRTBS_All": "    Always break after the return type.\n\n",
      "DRTBS_TopLevel": "    Always break after the return types of top-level functions.\n\n\n\n"
    }
  },
  "AlwaysBreakAfterReturnType": {
    "type": "ReturnTypeBreakingStyle",
    "description": "  The function declaration return type breaking style to use.\n\n    Possible values:\n\n",
    "enum": {
      "RTBS_None": "    Break after return type automatically.\n    ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n\n```cpp\n\n      class A {\n        int f() { return 0; };\n      };\n      int f();\n      int f() { return 1; }\n\n```\n\n",
      "RTBS_All": "    Always break after the return type.\n\n```cpp\n\n      class A {\n        int\n        f() {\n          return 0;\n        };\n      };\n      int\n      f();\n      int\n      f() {\n        return 1;\n      }\n\n```\n\n",
      "RTBS_TopLevel": "    Always break after the return types of top-level functions.\n\n```cpp\n\n      class A {\n        int f() { return 0; };\n      };\n      int\n      f();\n      int\n      f() {\n        return 1;\n      }\n\n```\n\n",
      "RTBS_AllDefinitions": "    Always break after the return type of function definitions.\n\n```cpp\n\n      class A {\n        int\n        f() {\n          return 0;\n        };\n      };\n      int f();\n      int\n      f() {\n        return 1;\n      }\n\n```\n\n",
      "RTBS_TopLevelDefinitions": "    Always break after the return type of top-level definitions.\n\n```cpp\n\n      class A {\n        int f() { return 0; };\n      };\n      int f();\n      int\n      f() {\n        return 1;\n      }\n\n\n\n```\n\n"
    }
  },
  "AlwaysBreakBeforeMultilineStrings": {
    "type": "bool",
    "description": "  If ``true``, always break before multiline string literals.\n\n  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  ``ContinuationIndentWidth`` spaces from the start of the line.\n\n```cpp\n\n     true:                                  false:\n     aaaa =                         vs.     aaaa = \"bbbb\"\n         \"bbbb\"                                    \"cccc\";\n         \"cccc\";\n\n```"
  },
  "AlwaysBreakTemplateDeclarations": {
    "type": "BreakTemplateDeclarationsStyle",
    "description": "  The template declaration breaking style to use.\n\n    Possible values:\n\n",
    "enum": {
      "BTDS_No": "    Do not force break before declaration.\n    ``PenaltyBreakTemplateDeclaration`` is taken into account.\n\n```cpp\n\n       template <typename T> T foo() {\n       }\n       template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,\n                                   int bbbbbbbbbbbbbbbbbbbbb) {\n       }\n\n```\n\n",
      "BTDS_MultiLine": "    Force break after template declaration only when the following\n    declaration spans multiple lines.\n\n```cpp\n\n       template <typename T> T foo() {\n       }\n       template <typename T>\n       T foo(int aaaaaaaaaaaaaaaaaaaaa,\n             int bbbbbbbbbbbbbbbbbbbbb) {\n       }\n\n```\n\n",
      "BTDS_Yes": "    Always break after template declaration.\n\n```cpp\n\n       template <typename T>\n       T foo() {\n       }\n       template <typename T>\n       T foo(int aaaaaaaaaaaaaaaaaaaaa,\n             int bbbbbbbbbbbbbbbbbbbbb) {\n       }\n\n\n\n```\n\n"
    }
  },
  "AttributeMacros": {
    "type": "std::vector<std::string>",
    "description": "  A vector of strings that should be interpreted as attributes/qualifiers\n  instead of identifiers. This can be useful for language extensions or\n  static analyzer annotations.\n\n  For example:\n\n```cpp\n\n    x = (char *__capability)&y;\n    int function(void) __ununsed;\n    void only_writes_to_buffer(char *__output buffer);\n\n  In the .clang-format configuration file, this can be configured like:\n\n```yaml\n\n    AttributeMacros: ['__capability', '__output', '__ununsed']\n\n```"
  },
  "BinPackArguments": {
    "type": "bool",
    "description": "  If ``false``, a function call's arguments will either be all on the\n  same line or will have one line each.\n\n```cpp\n\n    true:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n\n    false:\n    void f() {\n      f(aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaa,\n        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n    }\n\n```"
  },
  "BinPackParameters": {
    "type": "bool",
    "description": "  If ``false``, a function declaration's or function definition's\n  parameters will either all be on the same line or will have one line each.\n\n```cpp\n\n    true:\n    void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n\n    false:\n    void f(int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaa,\n           int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n\n```"
  },
  "BitFieldColonSpacing": {
    "type": "BitFieldColonSpacingStyle",
    "description": "  The BitFieldColonSpacingStyle to use for bitfields.\n\n    Possible values:\n\n",
    "enum": {
      "BFCS_Both": "    Add one space on each side of the ``:``\n\n```cpp\n\n      unsigned bf : 2;\n\n```\n\n",
      "BFCS_None": "    Add no space around the ``:`` (except when needed for\n    ``AlignConsecutiveBitFields``).\n\n```cpp\n\n      unsigned bf:2;\n\n```\n\n",
      "BFCS_Before": "    Add space before the ``:`` only\n\n```cpp\n\n      unsigned bf :2;\n\n```\n\n",
      "BFCS_After": "    Add space after the ``:`` only (space may be added before if\n    needed for ``AlignConsecutiveBitFields``).\n\n```cpp\n\n      unsigned bf: 2;\n\n\n\n```\n\n"
    }
  },
  "BraceWrapping": {
    "type": "BraceWrappingFlags",
    "description": "  Control of individual brace wrapping cases.\n\n  If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.\n\n```yaml\n\n    # Example of usage:\n    BreakBeforeBraces: Custom\n    BraceWrapping:\n      AfterEnum: true\n      AfterStruct: false\n      SplitEmptyFunction: false\n\n  Nested configuration flags:\n\n\n  * ``bool AfterCaseLabel`` Wrap case labels.\n\n```cpp\n\n      false:                                true:\n      switch (foo) {                vs.     switch (foo) {\n        case 1: {                             case 1:\n          bar();                              {\n          break;                                bar();\n        }                                       break;\n        default: {                            }\n          plop();                             default:\n        }                                     {\n      }                                         plop();\n                                              }\n                                            }\n\n  * ``bool AfterClass`` Wrap class definitions.\n\n```cpp\n\n      true:\n      class foo {};\n\n      false:\n      class foo\n      {};\n\n  * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``\n    Wrap control statements (``if``/``for``/``while``/``switch``/..).\n\n    Possible values:\n\n```",
    "enum": {
      "BWACS_Never": "      Never wrap braces after a control statement.\n\n```cpp\n\n        if (foo()) {\n        } else {\n        }\n        for (int i = 0; i < 10; ++i) {\n        }\n\n```\n\n",
      "BWACS_MultiLine": "      Only wrap braces after a multi-line control statement.\n\n```cpp\n\n        if (foo && bar &&\n            baz)\n        {\n          quux();\n        }\n        while (foo || bar) {\n        }\n\n```\n\n",
      "BWACS_Always": "      Always wrap braces after a control statement.\n\n```cpp\n\n        if (foo())\n        {\n        } else\n        {}\n        for (int i = 0; i < 10; ++i)\n        {}\n\n\n```\n\n",
      "bool AfterEnum": "\n```cpp\n\n      true:\n      enum X : int\n      {\n        B\n      };\n\n      false:\n      enum X : int { B };\n\n```\n\n",
      "bool AfterFunction": "\n```cpp\n\n      true:\n      void foo()\n      {\n        bar();\n        bar2();\n      }\n\n      false:\n      void foo() {\n        bar();\n        bar2();\n      }\n\n```\n\n",
      "bool AfterNamespace": "\n```cpp\n\n      true:\n      namespace\n      {\n      int foo();\n      int bar();\n      }\n\n      false:\n      namespace {\n      int foo();\n      int bar();\n      }\n\n```\n\n",
      "bool AfterObjCDeclaration": "    @autoreleasepool and @synchronized blocks are wrapped\n    according to `AfterControlStatement` flag.\n\n",
      "bool AfterStruct": "\n```cpp\n\n      true:\n      struct foo\n      {\n        int x;\n      };\n\n      false:\n      struct foo {\n        int x;\n      };\n\n```\n\n",
      "bool AfterUnion": "\n```cpp\n\n      true:\n      union foo\n      {\n        int x;\n      }\n\n      false:\n      union foo {\n        int x;\n      }\n\n```\n\n",
      "bool AfterExternBlock": "\n```cpp\n\n      true:\n      extern \"C\"\n      {\n        int foo();\n      }\n\n      false:\n      extern \"C\" {\n      int foo();\n      }\n\n```\n\n",
      "bool BeforeCatch": "\n```cpp\n\n      true:\n      try {\n        foo();\n      }\n      catch () {\n      }\n\n      false:\n      try {\n        foo();\n      } catch () {\n      }\n\n```\n\n",
      "bool BeforeElse": "\n```cpp\n\n      true:\n      if (foo()) {\n      }\n      else {\n      }\n\n      false:\n      if (foo()) {\n      } else {\n      }\n\n```\n\n",
      "bool BeforeLambdaBody": "\n```cpp\n\n      true:\n      connect(\n        []()\n        {\n          foo();\n          bar();\n        });\n\n      false:\n      connect([]() {\n        foo();\n        bar();\n      });\n\n```\n\n",
      "bool BeforeWhile": "\n```cpp\n\n      true:\n      do {\n        foo();\n      }\n      while (1);\n\n      false:\n      do {\n        foo();\n      } while (1);\n\n```\n\n",
      "bool IndentBraces": "\n",
      "bool SplitEmptyFunction": "    This option is used only if the opening brace of the function has\n    already been wrapped, i.e. the `AfterFunction` brace wrapping mode is\n    set, and the function could/should not be put on a single line (as per\n    `AllowShortFunctionsOnASingleLine` and constructor formatting options).\n\n```cpp\n\n      int f()   vs.   int f()\n      {}              {\n                      }\n\n```\n\n",
      "bool SplitEmptyRecord": "    can be put on a single line. This option is used only if the opening\n    brace of the record has already been wrapped, i.e. the `AfterClass`\n    (for classes) brace wrapping mode is set.\n\n```cpp\n\n      class Foo   vs.  class Foo\n      {}               {\n                       }\n\n```\n\n",
      "bool SplitEmptyNamespace": "    This option is used only if the opening brace of the namespace has\n    already been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\n    set.\n\n```cpp\n\n      namespace Foo   vs.  namespace Foo\n      {}                   {\n                           }\n\n\n```\n\n"
    }
  },
  "BreakAfterJavaFieldAnnotations": {
    "type": "bool",
    "description": "  Break after each annotation on a field in Java files.\n\n```java\n\n     true:                                  false:\n     @Partial                       vs.     @Partial @Mock DataLoad loader;\n     @Mock\n     DataLoad loader;\n\n```"
  },
  "BreakBeforeBinaryOperators": {
    "type": "BinaryOperatorStyle",
    "description": "  The way to wrap binary operators.\n\n    Possible values:\n\n",
    "enum": {
      "BOS_None": "    Break after operators.\n\n```cpp\n\n       LooooooooooongType loooooooooooooooooooooongVariable =\n           someLooooooooooooooooongFunction();\n\n       bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n                            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n                        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&\n                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >\n                        ccccccccccccccccccccccccccccccccccccccccc;\n\n```\n\n",
      "BOS_NonAssignment": "    Break before operators that aren't assignments.\n\n```cpp\n\n       LooooooooooongType loooooooooooooooooooooongVariable =\n           someLooooooooooooooooongFunction();\n\n       bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                            + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                        == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                    && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                           > ccccccccccccccccccccccccccccccccccccccccc;\n\n```\n\n",
      "BOS_All": "    Break before operators.\n\n```cpp\n\n       LooooooooooongType loooooooooooooooooooooongVariable\n           = someLooooooooooooooooongFunction();\n\n       bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                            + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                        == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                    && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n                           > ccccccccccccccccccccccccccccccccccccccccc;\n\n\n\n```\n\n"
    }
  },
  "BreakBeforeBraces": {
    "type": "BraceBreakingStyle",
    "description": "  The brace breaking style to use.\n\n    Possible values:\n\n",
    "enum": {
      "BS_Attach": "    Always attach braces to surrounding context.\n\n```cpp\n\n      namespace N {\n      enum E {\n        E1,\n        E2,\n      };\n\n      class C {\n      public:\n        C();\n      };\n\n      bool baz(int i) {\n        try {\n          do {\n            switch (i) {\n            case 1: {\n              foobar();\n              break;\n            }\n            default: {\n              break;\n            }\n            }\n          } while (--i);\n          return true;\n        } catch (...) {\n          handleError();\n          return false;\n        }\n      }\n\n      void foo(bool b) {\n        if (b) {\n          baz(2);\n        } else {\n          baz(5);\n        }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_Linux": "    Like ``Attach``, but break before braces on function, namespace and\n    class definitions.\n\n```cpp\n\n      namespace N\n      {\n      enum E {\n        E1,\n        E2,\n      };\n\n      class C\n      {\n      public:\n        C();\n      };\n\n      bool baz(int i)\n      {\n        try {\n          do {\n            switch (i) {\n            case 1: {\n              foobar();\n              break;\n            }\n            default: {\n              break;\n            }\n            }\n          } while (--i);\n          return true;\n        } catch (...) {\n          handleError();\n          return false;\n        }\n      }\n\n      void foo(bool b)\n      {\n        if (b) {\n          baz(2);\n        } else {\n          baz(5);\n        }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_Mozilla": "    Like ``Attach``, but break before braces on enum, function, and record\n    definitions.\n\n```cpp\n\n      namespace N {\n      enum E\n      {\n        E1,\n        E2,\n      };\n\n      class C\n      {\n      public:\n        C();\n      };\n\n      bool baz(int i)\n      {\n        try {\n          do {\n            switch (i) {\n            case 1: {\n              foobar();\n              break;\n            }\n            default: {\n              break;\n            }\n            }\n          } while (--i);\n          return true;\n        } catch (...) {\n          handleError();\n          return false;\n        }\n      }\n\n      void foo(bool b)\n      {\n        if (b) {\n          baz(2);\n        } else {\n          baz(5);\n        }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_Stroustrup": "    Like ``Attach``, but break before function definitions, ``catch``, and\n    ``else``.\n\n```cpp\n\n      namespace N {\n      enum E {\n        E1,\n        E2,\n      };\n\n      class C {\n      public:\n        C();\n      };\n\n      bool baz(int i)\n      {\n        try {\n          do {\n            switch (i) {\n            case 1: {\n              foobar();\n              break;\n            }\n            default: {\n              break;\n            }\n            }\n          } while (--i);\n          return true;\n        }\n        catch (...) {\n          handleError();\n          return false;\n        }\n      }\n\n      void foo(bool b)\n      {\n        if (b) {\n          baz(2);\n        }\n        else {\n          baz(5);\n        }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_Allman": "    Always break before braces.\n\n```cpp\n\n      namespace N\n      {\n      enum E\n      {\n        E1,\n        E2,\n      };\n\n      class C\n      {\n      public:\n        C();\n      };\n\n      bool baz(int i)\n      {\n        try\n        {\n          do\n          {\n            switch (i)\n            {\n            case 1:\n            {\n              foobar();\n              break;\n            }\n            default:\n            {\n              break;\n            }\n            }\n          } while (--i);\n          return true;\n        }\n        catch (...)\n        {\n          handleError();\n          return false;\n        }\n      }\n\n      void foo(bool b)\n      {\n        if (b)\n        {\n          baz(2);\n        }\n        else\n        {\n          baz(5);\n        }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_Whitesmiths": "    Like ``Allman`` but always indent braces and line up code with braces.\n\n```cpp\n\n      namespace N\n        {\n      enum E\n        {\n        E1,\n        E2,\n        };\n\n      class C\n        {\n      public:\n        C();\n        };\n\n      bool baz(int i)\n        {\n        try\n          {\n          do\n            {\n            switch (i)\n              {\n              case 1:\n              {\n              foobar();\n              break;\n              }\n              default:\n              {\n              break;\n              }\n              }\n            } while (--i);\n          return true;\n          }\n        catch (...)\n          {\n          handleError();\n          return false;\n          }\n        }\n\n      void foo(bool b)\n        {\n        if (b)\n          {\n          baz(2);\n          }\n        else\n          {\n          baz(5);\n          }\n        }\n\n      void bar() { foo(true); }\n        } // namespace N\n\n```\n\n",
      "BS_GNU": "    Always break before braces and add an extra level of indentation to\n    braces of control statements, not to those of class, function\n    or other definitions.\n\n```cpp\n\n      namespace N\n      {\n      enum E\n      {\n        E1,\n        E2,\n      };\n\n      class C\n      {\n      public:\n        C();\n      };\n\n      bool baz(int i)\n      {\n        try\n          {\n            do\n              {\n                switch (i)\n                  {\n                  case 1:\n                    {\n                      foobar();\n                      break;\n                    }\n                  default:\n                    {\n                      break;\n                    }\n                  }\n              }\n            while (--i);\n            return true;\n          }\n        catch (...)\n          {\n            handleError();\n            return false;\n          }\n      }\n\n      void foo(bool b)\n      {\n        if (b)\n          {\n            baz(2);\n          }\n        else\n          {\n            baz(5);\n          }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_WebKit": "    Like ``Attach``, but break before functions.\n\n```cpp\n\n      namespace N {\n      enum E {\n        E1,\n        E2,\n      };\n\n      class C {\n      public:\n        C();\n      };\n\n      bool baz(int i)\n      {\n        try {\n          do {\n            switch (i) {\n            case 1: {\n              foobar();\n              break;\n            }\n            default: {\n              break;\n            }\n            }\n          } while (--i);\n          return true;\n        } catch (...) {\n          handleError();\n          return false;\n        }\n      }\n\n      void foo(bool b)\n      {\n        if (b) {\n          baz(2);\n        } else {\n          baz(5);\n        }\n      }\n\n      void bar() { foo(true); }\n      } // namespace N\n\n```\n\n",
      "BS_Custom": "    Configure each individual brace in `BraceWrapping`.\n\n\n\n"
    }
  },
  "BreakBeforeConceptDeclarations": {
    "type": "bool",
    "description": "  If ``true``, concept will be placed on a new line.\n\n```cpp\n\n    true:\n     template<typename T>\n     concept ...\n\n    false:\n     template<typename T> concept ...\n\n```"
  },
  "BreakBeforeTernaryOperators": {
    "type": "bool",
    "description": "  If ``true``, ternary operators will be placed after line breaks.\n\n```cpp\n\n     true:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n         ? firstValue\n         : SecondValueVeryVeryVeryVeryLong;\n\n     false:\n     veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n         firstValue :\n         SecondValueVeryVeryVeryVeryLong;\n\n```"
  },
  "BreakConstructorInitializers": {
    "type": "BreakConstructorInitializersStyle",
    "description": "  The constructor initializers style to use.\n\n    Possible values:\n\n",
    "enum": {
      "BCIS_BeforeColon": "    Break constructor initializers before the colon and after the commas.\n\n```cpp\n\n       Constructor()\n           : initializer1(),\n             initializer2()\n\n```\n\n",
      "BCIS_BeforeComma": "    Break constructor initializers before the colon and commas, and align\n    the commas with the colon.\n\n```cpp\n\n       Constructor()\n           : initializer1()\n           , initializer2()\n\n```\n\n",
      "BCIS_AfterColon": "    Break constructor initializers after the colon and commas.\n\n```cpp\n\n       Constructor() :\n           initializer1(),\n           initializer2()\n\n\n\n```\n\n"
    }
  },
  "BreakInheritanceList": {
    "type": "BreakInheritanceListStyle",
    "description": "  The inheritance list style to use.\n\n    Possible values:\n\n",
    "enum": {
      "BILS_BeforeColon": "    Break inheritance list before the colon and after the commas.\n\n```cpp\n\n       class Foo\n           : Base1,\n             Base2\n       {};\n\n```\n\n",
      "BILS_BeforeComma": "    Break inheritance list before the colon and commas, and align\n    the commas with the colon.\n\n```cpp\n\n       class Foo\n           : Base1\n           , Base2\n       {};\n\n```\n\n",
      "BILS_AfterColon": "    Break inheritance list after the colon and commas.\n\n```cpp\n\n       class Foo :\n           Base1,\n           Base2\n       {};\n\n\n\n```\n\n"
    }
  },
  "BreakStringLiterals": {
    "type": "bool",
    "description": "  Allow breaking string literals when formatting.\n\n```cpp\n\n     true:\n     const char* x = \"veryVeryVeryVeryVeryVe\"\n                     \"ryVeryVeryVeryVeryVery\"\n                     \"VeryLongString\";\n\n     false:\n     const char* x =\n       \"veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString\";\n\n```"
  },
  "ColumnLimit": {
    "type": "unsigned",
    "description": "  The column limit.\n\n  A column limit of ``0`` means that there is no column limit. In this case,\n  clang-format will respect the input's line breaking decisions within\n  statements unless they contradict other rules.\n\n"
  },
  "CommentPragmas": {
    "type": "std::string",
    "description": "  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.\n\n```cpp\n\n     // CommentPragmas: '^ FOOBAR pragma:'\n     // Will leave the following line unaffected\n     #include <vector> // FOOBAR pragma: keep\n\n```"
  },
  "CompactNamespaces": {
    "type": "bool",
    "description": "  If ``true``, consecutive namespace declarations will be on the same\n  line. If ``false``, each namespace is declared on a new line.\n\n```cpp\n\n    true:\n    namespace Foo { namespace Bar {\n    }}\n\n    false:\n    namespace Foo {\n    namespace Bar {\n    }\n    }\n\n  If it does not fit on a single line, the overflowing namespaces get\n  wrapped:\n\n```cpp\n\n    namespace Foo { namespace Bar {\n    namespace Extra {\n    }}}\n\n```"
  },
  "ConstructorInitializerAllOnOneLineOrOnePerLine": {
    "type": "bool",
    "description": "  If the constructor initializers don't fit on a line, put each\n  initializer on its own line.\n\n```cpp\n\n    true:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n\n    false:\n    SomeClass::Constructor()\n        : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n          aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n      return 0;\n    }\n\n```"
  },
  "ConstructorInitializerIndentWidth": {
    "type": "unsigned",
    "description": "  The number of characters to use for indentation of constructor\n  initializer lists as well as inheritance lists.\n\n"
  },
  "ContinuationIndentWidth": {
    "type": "unsigned",
    "description": "  Indent width for line continuations.\n\n```cpp\n\n     ContinuationIndentWidth: 2\n\n     int i =         //  VeryVeryVeryVeryVeryLongComment\n       longFunction( // Again a long comment\n         arg);\n\n```"
  },
  "Cpp11BracedListStyle": {
    "type": "bool",
    "description": "  If ``true``, format braced lists as best suited for C++11 braced\n  lists.\n\n  Important differences:\n  - No spaces inside the braced list.\n  - No line break before the closing brace.\n  - Indentation with the continuation indent, not with the block indent.\n\n  Fundamentally, C++11 braced lists are formatted exactly like function\n  calls would be formatted in their place. If the braced list follows a name\n  (e.g. a type or variable name), clang-format formats as if the ``{}`` were\n  the parentheses of a function call with that name. If there is no name,\n  a zero-length name is assumed.\n\n```cpp\n\n     true:                                  false:\n     vector<int> x{1, 2, 3, 4};     vs.     vector<int> x{ 1, 2, 3, 4 };\n     vector<T> x{{}, {}, {}, {}};           vector<T> x{ {}, {}, {}, {} };\n     f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n     new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n\n```"
  },
  "DeriveLineEnding": {
    "type": "bool",
    "description": "  Analyze the formatted file for the most used line ending (``\\r\\n``\n  or ``\\n``). ``UseCRLF`` is only used as a fallback if none can be derived.\n\n"
  },
  "DerivePointerAlignment": {
    "type": "bool",
    "description": "  If ``true``, analyze the formatted file for the most common\n  alignment of ``&`` and ``*``.\n  Pointer and reference alignment styles are going to be updated according\n  to the preferences found in the file.\n  ``PointerAlignment`` is then used only as fallback.\n\n"
  },
  "DisableFormat": {
    "type": "bool",
    "description": "  Disables formatting completely.\n\n"
  },
  "EmptyLineBeforeAccessModifier": {
    "type": "EmptyLineBeforeAccessModifierStyle",
    "description": "  Defines in which cases to put empty line before access modifiers.\n\n    Possible values:\n\n",
    "enum": {
      "ELBAMS_Never": "    Remove all empty lines before access modifiers.\n\n```cpp\n\n      struct foo {\n      private:\n        int i;\n      protected:\n        int j;\n        /* comment */\n      public:\n        foo() {}\n      private:\n      protected:\n      };\n\n```\n\n",
      "ELBAMS_Leave": "    Keep existing empty lines before access modifiers.\n\n",
      "ELBAMS_LogicalBlock": "    Add empty line only when access modifier starts a new logical block.\n    Logical block is a group of one or more member fields or functions.\n\n```cpp\n\n      struct foo {\n      private:\n        int i;\n\n      protected:\n        int j;\n        /* comment */\n      public:\n        foo() {}\n\n      private:\n      protected:\n      };\n\n```\n\n",
      "ELBAMS_Always": "    Always add empty line before access modifiers unless access modifier\n    is at the start of struct or class definition.\n\n```cpp\n\n      struct foo {\n      private:\n        int i;\n\n      protected:\n        int j;\n        /* comment */\n\n      public:\n        foo() {}\n\n      private:\n\n      protected:\n      };\n\n\n\n```\n\n"
    }
  },
  "ExperimentalAutoDetectBinPacking": {
    "type": "bool",
    "description": "  If ``true``, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.\n\n  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.\n\n  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.\n\n"
  },
  "FixNamespaceComments": {
    "type": "bool",
    "description": "  If ``true``, clang-format adds missing namespace end comments and\n  fixes invalid existing ones.\n\n```cpp\n\n     true:                                  false:\n     namespace a {                  vs.     namespace a {\n     foo();                                 foo();\n     } // namespace a                       }\n\n```"
  },
  "ForEachMacros": {
    "type": "std::vector<std::string>",
    "description": "  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.\n\n  These are expected to be macros of the form:\n\n```cpp\n\n    FOREACH(<variable-declaration>, ...)\n      <loop-body>\n\n  In the .clang-format configuration file, this can be configured like:\n\n```yaml\n\n    ForEachMacros: ['RANGES_FOR', 'FOREACH']\n\n  For example: BOOST_FOREACH.\n\n```"
  },
  "IncludeBlocks": {
    "type": "IncludeBlocksStyle",
    "description": "  Dependent on the value, multiple ``#include`` blocks can be sorted\n  as one and divided based on category.\n\n    Possible values:\n\n",
    "enum": {
      "IBS_Preserve": "    Sort each ``#include`` block separately.\n\n```cpp\n\n       #include \"b.h\"               into      #include \"b.h\"\n\n       #include <lib/main.h>                  #include \"a.h\"\n       #include \"a.h\"                         #include <lib/main.h>\n\n```\n\n",
      "IBS_Merge": "    Merge multiple ``#include`` blocks together and sort as one.\n\n```cpp\n\n       #include \"b.h\"               into      #include \"a.h\"\n                                              #include \"b.h\"\n       #include <lib/main.h>                  #include <lib/main.h>\n       #include \"a.h\"\n\n```\n\n",
      "IBS_Regroup": "    Merge multiple ``#include`` blocks together and sort as one.\n    Then split into groups based on category priority. See\n    ``IncludeCategories``.\n\n```cpp\n\n       #include \"b.h\"               into      #include \"a.h\"\n                                              #include \"b.h\"\n       #include <lib/main.h>\n       #include \"a.h\"                         #include <lib/main.h>\n\n\n\n```\n\n"
    }
  },
  "IncludeCategories": {
    "type": "std::vector<IncludeCategory>",
    "description": "  Regular expressions denoting the different ``#include`` categories\n  used for ordering ``#includes``.\n\n  `POSIX extended\n  <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_\n  regular expressions are supported.\n\n  These regular expressions are matched against the filename of an include\n  (including the <> or \"\") in order. The value belonging to the first\n  matching regular expression is assigned and ``#includes`` are sorted first\n  according to increasing category number and then alphabetically within\n  each category.\n\n  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the ``#includes``\n  (https://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.\n\n  There is a third and optional field ``SortPriority`` which can used while\n  ``IncludeBlocks = IBS_Regroup`` to define the priority in which\n  ``#includes`` should be ordered. The value of ``Priority`` defines the\n  order of ``#include blocks`` and also allows the grouping of ``#includes``\n  of different priority. ``SortPriority`` is set to the value of\n  ``Priority`` as default if it is not assigned.\n\n  Each regular expression can be marked as case sensitive with the field\n  ``CaseSensitive``, per default it is not.\n\n  To configure this in the .clang-format file, use:\n\n```yaml\n\n    IncludeCategories:\n      - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n        Priority:        2\n        SortPriority:    2\n        CaseSensitive:   true\n      - Regex:           '^(<|\"(gtest|gmock|isl|json)/)'\n        Priority:        3\n      - Regex:           '<[[:alnum:].]+>'\n        Priority:        4\n      - Regex:           '.*'\n        Priority:        1\n        SortPriority:    0\n\n```"
  },
  "IncludeIsMainRegex": {
    "type": "std::string",
    "description": "  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.\n\n  When guessing whether a #include is the \"main\" include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:\n  - \"\" means \"arbitrary suffix\"\n  - \"$\" means \"no suffix\"\n\n  For example, if configured to \"(_test)?$\", then a header a.h would be seen\n  as the \"main\" include in both a.cc and a_test.cc.\n\n"
  },
  "IncludeIsMainSourceRegex": {
    "type": "std::string",
    "description": "  Specify a regular expression for files being formatted\n  that are allowed to be considered \"main\" in the\n  file-to-main-include mapping.\n\n  By default, clang-format considers files as \"main\" only when they end\n  with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``\n  extensions.\n  For these files a guessing of \"main\" include takes place\n  (to assign category 0, see above). This config option allows for\n  additional suffixes and extensions for files to be considered as \"main\".\n\n  For example, if this option is configured to ``(Impl\\.hpp)$``,\n  then a file ``ClassImpl.hpp`` is considered \"main\" (in addition to\n  ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and \"main\n  include file\" logic will be executed (with *IncludeIsMainRegex* setting\n  also being respected in later phase). Without this option set,\n  ``ClassImpl.hpp`` would not have the main include file put on top\n  before any other include.\n\n"
  },
  "IndentCaseBlocks": {
    "type": "bool",
    "description": "  Indent case label blocks one level from the case label.\n\n  When ``false``, the block following the case label uses the same\n  indentation level as for the case label, treating the case label the same\n  as an if-statement.\n  When ``true``, the block gets indented as a scope block.\n\n```cpp\n\n     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1: {                              case 1:\n       bar();                                 {\n     } break;                                   bar();\n     default: {                               }\n       plop();                                break;\n     }                                      default:\n     }                                        {\n                                                plop();\n                                              }\n                                            }\n\n```"
  },
  "IndentCaseLabels": {
    "type": "bool",
    "description": "  Indent case labels one level from the switch statement.\n\n  When ``false``, use the same indentation level as for the switch\n  statement. Switch statement body is always indented one level more than\n  case labels (except the first block following the case label, which\n  itself indents the code - unless IndentCaseBlocks is enabled).\n\n```cpp\n\n     false:                                 true:\n     switch (fool) {                vs.     switch (fool) {\n     case 1:                                  case 1:\n       bar();                                   bar();\n       break;                                   break;\n     default:                                 default:\n       plop();                                  plop();\n     }                                      }\n\n```"
  },
  "IndentExternBlock": {
    "type": "IndentExternBlockStyle",
    "description": "  IndentExternBlockStyle is the type of indenting of extern blocks.\n\n    Possible values:\n\n",
    "enum": {
      "IEBS_AfterExternBlock": "    Backwards compatible with AfterExternBlock's indenting.\n\n```cpp\n\n       IndentExternBlock: AfterExternBlock\n       BraceWrapping.AfterExternBlock: true\n       extern \"C\"\n       {\n           void foo();\n       }\n\n\n```cpp\n\n       IndentExternBlock: AfterExternBlock\n       BraceWrapping.AfterExternBlock: false\n       extern \"C\" {\n       void foo();\n       }\n\n```\n\n",
      "IEBS_NoIndent": "    Does not indent extern blocks.\n\n```cpp\n\n        extern \"C\" {\n        void foo();\n        }\n\n```\n\n",
      "IEBS_Indent": "    Indents extern blocks.\n\n```cpp\n\n        extern \"C\" {\n          void foo();\n        }\n\n\n\n```\n\n"
    }
  },
  "IndentGotoLabels": {
    "type": "bool",
    "description": "  Indent goto labels.\n\n  When ``false``, goto labels are flushed left.\n\n```cpp\n\n     true:                                  false:\n     int f() {                      vs.     int f() {\n       if (foo()) {                           if (foo()) {\n       label1:                              label1:\n         bar();                                 bar();\n       }                                      }\n     label2:                                label2:\n       return 1;                              return 1;\n     }                                      }\n\n```"
  },
  "IndentPPDirectives": {
    "type": "PPDirectiveIndentStyle",
    "description": "  The preprocessor directive indenting style to use.\n\n    Possible values:\n\n",
    "enum": {
      "PPDIS_None": "    Does not indent any directives.\n\n```cpp\n\n       #if FOO\n       #if BAR\n       #include <foo>\n       #endif\n       #endif\n\n```\n\n",
      "PPDIS_AfterHash": "    Indents directives after the hash.\n\n```cpp\n\n       #if FOO\n       #  if BAR\n       #    include <foo>\n       #  endif\n       #endif\n\n```\n\n",
      "PPDIS_BeforeHash": "    Indents directives before the hash.\n\n```cpp\n\n       #if FOO\n         #if BAR\n           #include <foo>\n         #endif\n       #endif\n\n\n\n```\n\n"
    }
  },
  "IndentRequires": {
    "type": "bool",
    "description": "  Indent the requires clause in a template\n\n```cpp\n\n     true:\n     template <typename It>\n       requires Iterator<It>\n     void sort(It begin, It end) {\n       //....\n     }\n\n     false:\n     template <typename It>\n     requires Iterator<It>\n     void sort(It begin, It end) {\n       //....\n     }\n\n```"
  },
  "IndentWidth": {
    "type": "unsigned",
    "description": "  The number of columns to use for indentation.\n\n```cpp\n\n     IndentWidth: 3\n\n     void f() {\n        someFunction();\n        if (true, false) {\n           f();\n        }\n     }\n\n```"
  },
  "IndentWrappedFunctionNames": {
    "type": "bool",
    "description": "  Indent if a function definition or declaration is wrapped after the\n  type.\n\n```cpp\n\n     true:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n         LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n\n     false:\n     LoooooooooooooooooooooooooooooooooooooooongReturnType\n     LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n\n```"
  },
  "InsertTrailingCommas": {
    "type": "TrailingCommaStyle",
    "description": "  If set to ``TCS_Wrapped`` will insert trailing commas in container\n  literals (arrays and objects) that wrap across multiple lines.\n  It is currently only available for JavaScript\n  and disabled by default ``TCS_None``.\n  ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``\n  as inserting the comma disables bin-packing.\n\n```cpp\n\n    TSC_Wrapped:\n    const someArray = [\n    aaaaaaaaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaa,\n    aaaaaaaaaaaaaaaaaaaaaaaaaa,\n    //                        ^ inserted\n    ]\n\n    Possible values:\n\n```",
    "enum": {
      "TCS_None": "    Do not insert trailing commas.\n\n",
      "TCS_Wrapped": "    Insert trailing commas in container literals that were wrapped over\n    multiple lines. Note that this is conceptually incompatible with\n    bin-packing, because the trailing comma is used as an indicator\n    that a container should be formatted one-per-line (i.e. not bin-packed).\n    So inserting a trailing comma counteracts bin-packing.\n\n\n\n"
    }
  },
  "JavaImportGroups": {
    "type": "std::vector<std::string>",
    "description": "  A vector of prefixes ordered by the desired groups for Java imports.\n\n  One group's prefix can be a subset of another - the longest prefix is\n  always matched. Within a group, the imports are ordered lexicographically.\n  Static imports are grouped separately and follow the same group rules.\n  By default, static imports are placed before non-static imports,\n  but this behavior is changed by another option,\n  ``SortJavaStaticImport``.\n\n  In the .clang-format configuration file, this can be configured like\n  in the following yaml example. This will result in imports being\n  formatted as in the Java example below.\n\n```yaml\n\n    JavaImportGroups: ['com.example', 'com', 'org']\n\n\n```java\n\n     import static com.example.function1;\n\n     import static com.test.function2;\n\n     import static org.example.function3;\n\n     import com.example.ClassA;\n     import com.example.Test;\n     import com.example.a.ClassB;\n\n     import com.test.ClassC;\n\n     import org.example.ClassD;\n\n```"
  },
  "JavaScriptQuotes": {
    "type": "JavaScriptQuoteStyle",
    "description": "  The JavaScriptQuoteStyle to use for JavaScript strings.\n\n    Possible values:\n\n",
    "enum": {
      "JSQS_Leave": "    Leave string quotes as they are.\n\n```js\n\n       string1 = \"foo\";\n       string2 = 'bar';\n\n```\n\n",
      "JSQS_Single": "    Always use single quotes.\n\n```js\n\n       string1 = 'foo';\n       string2 = 'bar';\n\n```\n\n",
      "JSQS_Double": "    Always use double quotes.\n\n```js\n\n       string1 = \"foo\";\n       string2 = \"bar\";\n\n\n\n```\n\n"
    }
  },
  "JavaScriptWrapImports": {
    "type": "bool",
    "description": "  Whether to wrap JavaScript import/export statements.\n\n```js\n\n     true:\n     import {\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n         VeryLongImportsAreAnnoying,\n     } from 'some/module.js'\n\n     false:\n     import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from \"some/module.js\"\n\n```"
  },
  "KeepEmptyLinesAtTheStartOfBlocks": {
    "type": "bool",
    "description": "  If true, the empty line at the start of blocks is kept.\n\n```cpp\n\n     true:                                  false:\n     if (foo) {                     vs.     if (foo) {\n                                              bar();\n       bar();                               }\n     }\n\n```"
  },
  "Language": {
    "type": "LanguageKind",
    "description": "  Language, this format style is targeted at.\n\n    Possible values:\n\n",
    "enum": {
      "LK_None": "    Do not use.\n\n",
      "LK_Cpp": "    Should be used for C, C++.\n\n",
      "LK_CSharp": "    Should be used for C#.\n\n",
      "LK_Java": "    Should be used for Java.\n\n",
      "LK_JavaScript": "    Should be used for JavaScript.\n\n",
      "LK_ObjC": "    Should be used for Objective-C, Objective-C++.\n\n",
      "LK_Proto": "    Should be used for Protocol Buffers\n    (https://developers.google.com/protocol-buffers/).\n\n",
      "LK_TableGen": "    Should be used for TableGen code.\n\n",
      "LK_TextProto": "    Should be used for Protocol Buffer messages in text format\n    (https://developers.google.com/protocol-buffers/).\n\n\n\n"
    }
  },
  "MacroBlockBegin": {
    "type": "std::string",
    "description": "  A regular expression matching macros that start a block.\n\n```cpp\n\n     # With:\n     MacroBlockBegin: \"^NS_MAP_BEGIN|\\\n     NS_TABLE_HEAD$\"\n     MacroBlockEnd: \"^\\\n     NS_MAP_END|\\\n     NS_TABLE_.*_END$\"\n\n     NS_MAP_BEGIN\n       foo();\n     NS_MAP_END\n\n     NS_TABLE_HEAD\n       bar();\n     NS_TABLE_FOO_END\n\n     # Without:\n     NS_MAP_BEGIN\n     foo();\n     NS_MAP_END\n\n     NS_TABLE_HEAD\n     bar();\n     NS_TABLE_FOO_END\n\n```"
  },
  "MacroBlockEnd": {
    "type": "std::string",
    "description": "  A regular expression matching macros that end a block.\n\n"
  },
  "MaxEmptyLinesToKeep": {
    "type": "unsigned",
    "description": "  The maximum number of consecutive empty lines to keep.\n\n```cpp\n\n     MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n     int f() {                              int f() {\n       int = 1;                                 int i = 1;\n                                                i = foo();\n       i = foo();                               return i;\n                                            }\n       return i;\n     }\n\n```"
  },
  "NamespaceIndentation": {
    "type": "NamespaceIndentationKind",
    "description": "  The indentation used for namespaces.\n\n    Possible values:\n\n",
    "enum": {
      "NI_None": "    Don't indent in namespaces.\n\n```cpp\n\n       namespace out {\n       int i;\n       namespace in {\n       int i;\n       }\n       }\n\n```\n\n",
      "NI_Inner": "    Indent only in inner namespaces (nested in other namespaces).\n\n```cpp\n\n       namespace out {\n       int i;\n       namespace in {\n         int i;\n       }\n       }\n\n```\n\n",
      "NI_All": "    Indent in all namespaces.\n\n```cpp\n\n       namespace out {\n         int i;\n         namespace in {\n           int i;\n         }\n       }\n\n\n\n```\n\n"
    }
  },
  "NamespaceMacros": {
    "type": "std::vector<std::string>",
    "description": "  A vector of macros which are used to open namespace blocks.\n\n  These are expected to be macros of the form:\n\n```cpp\n\n    NAMESPACE(<namespace-name>, ...) {\n      <namespace-content>\n    }\n\n  For example: TESTSUITE\n\n```"
  },
  "ObjCBinPackProtocolList": {
    "type": "BinPackStyle",
    "description": "  Controls bin-packing Objective-C protocol conformance list\n  items into as few lines as possible when they go over ``ColumnLimit``.\n\n  If ``Auto`` (the default), delegates to the value in\n  ``BinPackParameters``. If that is ``true``, bin-packs Objective-C\n  protocol conformance list items into as few lines as possible\n  whenever they go over ``ColumnLimit``.\n\n  If ``Always``, always bin-packs Objective-C protocol conformance\n  list items into as few lines as possible whenever they go over\n  ``ColumnLimit``.\n\n  If ``Never``, lays out Objective-C protocol conformance list items\n  onto individual lines whenever they go over ``ColumnLimit``.\n\n\n```objc\n\n     Always (or Auto, if BinPackParameters=true):\n     @interface ccccccccccccc () <\n         ccccccccccccc, ccccccccccccc,\n         ccccccccccccc, ccccccccccccc> {\n     }\n\n     Never (or Auto, if BinPackParameters=false):\n     @interface ddddddddddddd () <\n         ddddddddddddd,\n         ddddddddddddd,\n         ddddddddddddd,\n         ddddddddddddd> {\n     }\n\n    Possible values:\n\n```",
    "enum": {
      "BPS_Auto": "    Automatically determine parameter bin-packing behavior.\n\n",
      "BPS_Always": "    Always bin-pack parameters.\n\n",
      "BPS_Never": "    Never bin-pack parameters.\n\n\n\n"
    }
  },
  "ObjCBlockIndentWidth": {
    "type": "unsigned",
    "description": "  The number of characters to use for indentation of ObjC blocks.\n\n```objc\n\n     ObjCBlockIndentWidth: 4\n\n     [operation setCompletionBlock:^{\n         [self onOperationDone];\n     }];\n\n```"
  },
  "ObjCBreakBeforeNestedBlockParam": {
    "type": "bool",
    "description": "  Break parameters list into lines when there is nested block\n  parameters in a function call.\n\n```cpp\n\n    false:\n     - (void)_aMethod\n     {\n         [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n         *u, NSNumber *v) {\n             u = c;\n         }]\n     }\n     true:\n     - (void)_aMethod\n     {\n        [self.test1 t:self\n                     w:self\n            callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n                 u = c;\n             }]\n     }\n\n```"
  },
  "ObjCSpaceAfterProperty": {
    "type": "bool",
    "description": "  Add a space after ``@property`` in Objective-C, i.e. use\n  ``@property (readonly)`` instead of ``@property(readonly)``.\n\n"
  },
  "ObjCSpaceBeforeProtocolList": {
    "type": "bool",
    "description": "  Add a space in front of an Objective-C protocol list, i.e. use\n  ``Foo <Protocol>`` instead of ``Foo<Protocol>``.\n\n"
  },
  "PenaltyBreakAssignment": {
    "type": "unsigned",
    "description": "  The penalty for breaking around an assignment operator.\n\n"
  },
  "PenaltyBreakBeforeFirstCallParameter": {
    "type": "unsigned",
    "description": "  The penalty for breaking a function call after ``call(``.\n\n"
  },
  "PenaltyBreakComment": {
    "type": "unsigned",
    "description": "  The penalty for each line break introduced inside a comment.\n\n"
  },
  "PenaltyBreakFirstLessLess": {
    "type": "unsigned",
    "description": "  The penalty for breaking before the first ``<<``.\n\n"
  },
  "PenaltyBreakString": {
    "type": "unsigned",
    "description": "  The penalty for each line break introduced inside a string literal.\n\n"
  },
  "PenaltyBreakTemplateDeclaration": {
    "type": "unsigned",
    "description": "  The penalty for breaking after template declaration.\n\n"
  },
  "PenaltyExcessCharacter": {
    "type": "unsigned",
    "description": "  The penalty for each character outside of the column limit.\n\n"
  },
  "PenaltyIndentedWhitespace": {
    "type": "unsigned",
    "description": "  Penalty for each character of whitespace indentation\n  (counted relative to leading non-whitespace column).\n\n"
  },
  "PenaltyReturnTypeOnItsOwnLine": {
    "type": "unsigned",
    "description": "  Penalty for putting the return type of a function onto its own\n  line.\n\n"
  },
  "PointerAlignment": {
    "type": "PointerAlignmentStyle",
    "description": "  Pointer and reference alignment style.\n\n    Possible values:\n\n",
    "enum": {
      "PAS_Left": "    Align pointer to the left.\n\n```cpp\n\n      int* a;\n\n```\n\n",
      "PAS_Right": "    Align pointer to the right.\n\n```cpp\n\n      int *a;\n\n```\n\n",
      "PAS_Middle": "    Align pointer in the middle.\n\n```cpp\n\n      int * a;\n\n\n\n```\n\n"
    }
  },
  "RawStringFormats": {
    "type": "std::vector<RawStringFormat>",
    "description": "  Defines hints for detecting supported languages code blocks in raw\n  strings.\n\n  A raw string with a matching delimiter or a matching enclosing function\n  name will be reformatted assuming the specified language based on the\n  style for that language defined in the .clang-format file. If no style has\n  been defined in the .clang-format file for the specific language, a\n  predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\n  found, the formatting is based on llvm style. A matching delimiter takes\n  precedence over a matching enclosing function name for determining the\n  language of the raw string contents.\n\n  If a canonical delimiter is specified, occurrences of other delimiters for\n  the same language will be updated to the canonical if possible.\n\n  There should be at most one specification per language and each delimiter\n  and enclosing function should not occur in multiple specifications.\n\n  To configure this in the .clang-format file, use:\n\n```yaml\n\n    RawStringFormats:\n      - Language: TextProto\n          Delimiters:\n            - 'pb'\n            - 'proto'\n          EnclosingFunctions:\n            - 'PARSE_TEXT_PROTO'\n          BasedOnStyle: google\n      - Language: Cpp\n          Delimiters:\n            - 'cc'\n            - 'cpp'\n          BasedOnStyle: llvm\n          CanonicalDelimiter: 'cc'\n\n```"
  },
  "ReflowComments": {
    "type": "bool",
    "description": "  If ``true``, clang-format will attempt to re-flow comments.\n\n```cpp\n\n     false:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n\n     true:\n     // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n     // information\n     /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n      * information */\n\n```"
  },
  "SortIncludes": {
    "type": "SortIncludesOptions",
    "description": "  Controls if and how clang-format will sort ``#includes``.\n\n  Possible Values:\n\n  * ``SI_Never`` (in configuration ``Never``)\n    Includes are never sorted.\n\n```cpp\n\n      #include \"B/A.h\"\n      #include \"A/B.h\"\n      #include \"a/b.h\"\n      #include \"A/b.h\"\n      #include \"B/a.h\"\n\n  * ``SI_CaseInsensitive`` (in configuration ``CaseInsensitive``)\n    Includes are sorted in an ASCIIbetical or case insensitive fashion.\n\n```cpp\n\n      #include \"A/B.h\"\n      #include \"A/b.h\"\n      #include \"B/A.h\"\n      #include \"B/a.h\"\n      #include \"a/b.h\"\n\n  * ``SI_CaseSensitive`` (in configuration ``CaseSensitive``)\n    Includes are sorted in an alphabetical or case sensitive fashion.\n\n```cpp\n\n      #include \"A/B.h\"\n      #include \"A/b.h\"\n      #include \"a/b.h\"\n      #include \"B/A.h\"\n      #include \"B/a.h\"\n\n```"
  },
  "SortJavaStaticImport": {
    "type": "SortJavaStaticImportOptions",
    "description": "  When sorting Java imports, by default static imports are placed before\n  non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  static imports are placed after non-static imports.\n\n    Possible values:\n\n",
    "enum": {
      "SJSIO_Before": "    Static imports are placed before non-static imports.\n\n```java\n\n      import static org.example.function1;\n\n      import org.example.ClassA;\n\n```\n\n",
      "SJSIO_After": "    Static imports are placed after non-static imports.\n\n```java\n\n      import org.example.ClassA;\n\n      import static org.example.function1;\n\n\n\n```\n\n"
    }
  },
  "SortUsingDeclarations": {
    "type": "bool",
    "description": "  If ``true``, clang-format will sort using declarations.\n\n  The order of using declarations is defined as follows:\n  Split the strings by \"::\" and discard any initial empty strings. The last\n  element of each list is a non-namespace name; all others are namespace\n  names. Sort the lists of names lexicographically, where the sort order of\n  individual names is that all non-namespace names come before all namespace\n  names, and within those groups, names are in case-insensitive\n  lexicographic order.\n\n```cpp\n\n     false:                                 true:\n     using std::cout;               vs.     using std::cin;\n     using std::cin;                        using std::cout;\n\n```"
  },
  "SpaceAfterCStyleCast": {
    "type": "bool",
    "description": "  If ``true``, a space is inserted after C style casts.\n\n```cpp\n\n     true:                                  false:\n     (int) i;                       vs.     (int)i;\n\n```"
  },
  "SpaceAfterLogicalNot": {
    "type": "bool",
    "description": "  If ``true``, a space is inserted after the logical not operator (``!``).\n\n```cpp\n\n     true:                                  false:\n     ! someExpression();            vs.     !someExpression();\n\n```"
  },
  "SpaceAfterTemplateKeyword": {
    "type": "bool",
    "description": "  If ``true``, a space will be inserted after the 'template' keyword.\n\n```cpp\n\n     true:                                  false:\n     template <int> void foo();     vs.     template<int> void foo();\n\n```"
  },
  "SpaceAroundPointerQualifiers": {
    "type": "SpaceAroundPointerQualifiersStyle",
    "description": "  Defines in which cases to put a space before or after pointer qualifiers\n\n    Possible values:\n\n",
    "enum": {
      "SAPQ_Default": "    Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    instead.\n\n```cpp\n\n       PointerAlignment: Left                 PointerAlignment: Right\n       void* const* x = NULL;         vs.     void *const *x = NULL;\n\n```\n\n",
      "SAPQ_Before": "    Ensure that there is a space before pointer qualifiers.\n\n```cpp\n\n       PointerAlignment: Left                 PointerAlignment: Right\n       void* const* x = NULL;         vs.     void * const *x = NULL;\n\n```\n\n",
      "SAPQ_After": "    Ensure that there is a space after pointer qualifiers.\n\n```cpp\n\n       PointerAlignment: Left                 PointerAlignment: Right\n       void* const * x = NULL;         vs.     void *const *x = NULL;\n\n```\n\n",
      "SAPQ_Both": "    Ensure that there is a space both before and after pointer qualifiers.\n\n```cpp\n\n       PointerAlignment: Left                 PointerAlignment: Right\n       void* const * x = NULL;         vs.     void * const *x = NULL;\n\n\n\n```\n\n"
    }
  },
  "SpaceBeforeAssignmentOperators": {
    "type": "bool",
    "description": "  If ``false``, spaces will be removed before assignment operators.\n\n```cpp\n\n     true:                                  false:\n     int a = 5;                     vs.     int a= 5;\n     a += 42;                               a+= 42;\n\n```"
  },
  "SpaceBeforeCaseColon": {
    "type": "bool",
    "description": "  If ``false``, spaces will be removed before case colon.\n\n```cpp\n\n    true:                                   false\n    switch (x) {                    vs.     switch (x) {\n      case 1 : break;                         case 1: break;\n    }                                       }\n\n```"
  },
  "SpaceBeforeCpp11BracedList": {
    "type": "bool",
    "description": "  If ``true``, a space will be inserted before a C++11 braced list\n  used to initialize an object (after the preceding identifier or type).\n\n```cpp\n\n     true:                                  false:\n     Foo foo { bar };               vs.     Foo foo{ bar };\n     Foo {};                                Foo{};\n     vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n     new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n\n```"
  },
  "SpaceBeforeCtorInitializerColon": {
    "type": "bool",
    "description": "  If ``false``, spaces will be removed before constructor initializer\n  colon.\n\n```cpp\n\n     true:                                  false:\n     Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n\n```"
  },
  "SpaceBeforeInheritanceColon": {
    "type": "bool",
    "description": "  If ``false``, spaces will be removed before inheritance colon.\n\n```cpp\n\n     true:                                  false:\n     class Foo : Bar {}             vs.     class Foo: Bar {}\n\n```"
  },
  "SpaceBeforeParens": {
    "type": "SpaceBeforeParensOptions",
    "description": "  Defines in which cases to put a space before opening parentheses.\n\n    Possible values:\n\n",
    "enum": {
      "SBPO_Never": "    Never put a space before opening parentheses.\n\n```cpp\n\n       void f() {\n         if(true) {\n           f();\n         }\n       }\n\n```\n\n",
      "SBPO_ControlStatements": "    Put a space before opening parentheses only after control statement\n    keywords (``for/if/while...``).\n\n```cpp\n\n       void f() {\n         if (true) {\n           f();\n         }\n       }\n\n```\n\n",
      "SBPO_ControlStatementsExceptForEachMacros": "    Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    ForEach macros. This is useful in projects where ForEach macros are\n    treated as function calls instead of control statements.\n\n```cpp\n\n       void f() {\n         Q_FOREACH(...) {\n           f();\n         }\n       }\n\n```\n\n",
      "SBPO_NonEmptyParentheses": "    Put a space before opening parentheses only if the parentheses are not\n    empty i.e. '()'\n\n```cpp\n\n      void() {\n        if (true) {\n          f();\n          g (x, y, z);\n        }\n      }\n\n```\n\n",
      "SBPO_Always": "    Always put a space before opening parentheses, except when it's\n    prohibited by the syntax rules (in function-like macro definitions) or\n    when determined by other style rules (after unary operators, opening\n    parentheses, etc.)\n\n```cpp\n\n       void f () {\n         if (true) {\n           f ();\n         }\n       }\n\n\n\n```\n\n"
    }
  },
  "SpaceBeforeRangeBasedForLoopColon": {
    "type": "bool",
    "description": "  If ``false``, spaces will be removed before range-based for loop\n  colon.\n\n```cpp\n\n     true:                                  false:\n     for (auto v : values) {}       vs.     for(auto v: values) {}\n\n```"
  },
  "SpaceBeforeSquareBrackets": {
    "type": "bool",
    "description": "  If ``true``, spaces will be before  ``[``.\n  Lambdas will not be affected. Only the first ``[`` will get a space added.\n\n```cpp\n\n     true:                                  false:\n     int a [5];                    vs.      int a[5];\n     int a [5][5];                 vs.      int a[5][5];\n\n```"
  },
  "SpaceInEmptyBlock": {
    "type": "bool",
    "description": "  If ``true``, spaces will be inserted into ``{}``.\n\n```cpp\n\n     true:                                false:\n     void f() { }                   vs.   void f() {}\n     while (true) { }                     while (true) {}\n\n```"
  },
  "SpaceInEmptyParentheses": {
    "type": "bool",
    "description": "  If ``true``, spaces may be inserted into ``()``.\n\n```cpp\n\n     true:                                false:\n     void f( ) {                    vs.   void f() {\n       int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n       if (true) {                          if (true) {\n         f( );                                f();\n       }                                    }\n     }                                    }\n\n```"
  },
  "SpacesBeforeTrailingComments": {
    "type": "unsigned",
    "description": "  The number of spaces before trailing line comments\n  (``//`` - comments).\n\n  This does not affect trailing block comments (``/*`` - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.\n\n```cpp\n\n     SpacesBeforeTrailingComments: 3\n     void f() {\n       if (true) {   // foo1\n         f();        // bar\n       }             // foo\n     }\n\n```"
  },
  "SpacesInAngles": {
    "type": "bool",
    "description": "  If ``true``, spaces will be inserted after ``<`` and before ``>``\n  in template argument lists.\n\n```cpp\n\n     true:                                  false:\n     static_cast< int >(arg);       vs.     static_cast<int>(arg);\n     std::function< void(int) > fct;        std::function<void(int)> fct;\n\n```"
  },
  "SpacesInCStyleCastParentheses": {
    "type": "bool",
    "description": "  If ``true``, spaces may be inserted into C style casts.\n\n```cpp\n\n     true:                                  false:\n     x = ( int32 )y                 vs.     x = (int32)y\n\n```"
  },
  "SpacesInConditionalStatement": {
    "type": "bool",
    "description": "  If ``true``, spaces will be inserted around if/for/switch/while\n  conditions.\n\n```cpp\n\n     true:                                  false:\n     if ( a )  { ... }              vs.     if (a) { ... }\n     while ( i < 5 )  { ... }               while (i < 5) { ... }\n\n```"
  },
  "SpacesInContainerLiterals": {
    "type": "bool",
    "description": "  If ``true``, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).\n\n```js\n\n     true:                                  false:\n     var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n     f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n\n```"
  },
  "SpacesInLineCommentPrefix": {
    "type": "SpacesInLineComment",
    "description": "  How many spaces are allowed at the start of a line comment. To disable the\n  maximum set it to ``-1``, apart from that the maximum takes precedence\n  over the minimum.\n  Minimum = 1 Maximum = -1\n  // One space is forced\n\n  //  but more spaces are possible\n\n  Minimum = 0\n  Maximum = 0\n  //Forces to start every comment directly after the slashes\n\n  Note that in line comment sections the relative indent of the subsequent\n  lines is kept, that means the following:\n\n```cpp\n\n  before:                                   after:\n  Minimum: 1\n  //if (b) {                                // if (b) {\n  //  return true;                          //   return true;\n  //}                                       // }\n\n  Maximum: 0\n  /// List:                                 ///List:\n  ///  - Foo                                /// - Foo\n  ///    - Bar                              ///   - Bar\n\n  Nested configuration flags:\n\n\n  * ``unsigned Minimum`` The minimum number of spaces at the start of the comment.\n\n  * ``unsigned Maximum`` The maximum number of spaces at the start of the comment.\n\n\n```"
  },
  "SpacesInParentheses": {
    "type": "bool",
    "description": "  If ``true``, spaces will be inserted after ``(`` and before ``)``.\n\n```cpp\n\n     true:                                  false:\n     t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n\n```"
  },
  "SpacesInSquareBrackets": {
    "type": "bool",
    "description": "  If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  Lambdas without arguments or unspecified size array declarations will not\n  be affected.\n\n```cpp\n\n     true:                                  false:\n     int a[ 5 ];                    vs.     int a[5];\n     std::unique_ptr<int[]> foo() {} // Won't be affected\n\n```"
  },
  "Standard": {
    "type": "LanguageStandard",
    "description": "  Parse and format C++ constructs compatible with this standard.\n\n```cpp\n\n     c++03:                                 latest:\n     vector<set<int> > x;           vs.     vector<set<int>> x;\n\n    Possible values:\n\n```",
    "enum": {
      "LS_Cpp03": "    Parse and format as C++03.\n    ``Cpp03`` is a deprecated alias for ``c++03``\n\n",
      "LS_Cpp11": "    Parse and format as C++11.\n\n",
      "LS_Cpp14": "    Parse and format as C++14.\n\n",
      "LS_Cpp17": "    Parse and format as C++17.\n\n",
      "LS_Cpp20": "    Parse and format as C++20.\n\n",
      "LS_Latest": "    Parse and format using the latest supported language version.\n    ``Cpp11`` is a deprecated alias for ``Latest``\n\n",
      "LS_Auto": "    Automatic detection based on the input.\n\n\n\n"
    }
  },
  "StatementAttributeLikeMacros": {
    "type": "std::vector<std::string>",
    "description": "  Macros which are ignored in front of a statement, as if they were an\n  attribute. So that they are not parsed as identifier, for example for Qts\n  emit.\n\n```cpp\n\n    AlignConsecutiveDeclarations: true\n    StatementAttributeLikeMacros: []\n    unsigned char data = 'x';\n    emit          signal(data); // This is parsed as variable declaration.\n\n    AlignConsecutiveDeclarations: true\n    StatementAttributeLikeMacros: [emit]\n    unsigned char data = 'x';\n    emit signal(data); // Now it's fine again.\n\n```"
  },
  "StatementMacros": {
    "type": "std::vector<std::string>",
    "description": "  A vector of macros that should be interpreted as complete\n  statements.\n\n  Typical macros are expressions, and require a semi-colon to be\n  added; sometimes this is not the case, and this allows to make\n  clang-format aware of such cases.\n\n  For example: Q_UNUSED\n\n"
  },
  "TabWidth": {
    "type": "unsigned",
    "description": "  The number of columns used for tab stops.\n\n"
  },
  "TypenameMacros": {
    "type": "std::vector<std::string>",
    "description": "  A vector of macros that should be interpreted as type declarations\n  instead of as function calls.\n\n  These are expected to be macros of the form:\n\n```cpp\n\n    STACK_OF(...)\n\n  In the .clang-format configuration file, this can be configured like:\n\n```yaml\n\n    TypenameMacros: ['STACK_OF', 'LIST']\n\n  For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n\n```"
  },
  "UseCRLF": {
    "type": "bool",
    "description": "  Use ``\\r\\n`` instead of ``\\n`` for line breaks.\n  Also used as fallback if ``DeriveLineEnding`` is true.\n\n"
  },
  "UseTab": {
    "type": "UseTabStyle",
    "description": "  The way to use tab characters in the resulting file.\n\n    Possible values:\n\n",
    "enum": {
      "UT_Never": "    Never use tab.\n\n",
      "UT_ForIndentation": "    Use tabs only for indentation.\n\n",
      "UT_ForContinuationAndIndentation": "    Fill all leading whitespace with tabs, and use spaces for alignment that\n    appears within a line (e.g. consecutive assignments and declarations).\n\n",
      "UT_AlignWithSpaces": "    Use tabs for line continuation and indentation, and spaces for\n    alignment.\n\n",
      "UT_Always": "    Use tabs whenever we need to fill whitespace that spans at least from\n    one tab stop to the next one.\n\n\n\n"
    }
  },
  "WhitespaceSensitiveMacros": {
    "type": "std::vector<std::string>",
    "description": "  A vector of macros which are whitespace-sensitive and should not\n  be touched.\n\n  These are expected to be macros of the form:\n\n```cpp\n\n    STRINGIZE(...)\n\n  In the .clang-format configuration file, this can be configured like:\n\n```yaml\n\n    WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n\n  For example: BOOST_PP_STRINGIZE\n"
  }
}

